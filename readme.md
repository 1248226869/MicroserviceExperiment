# 微服务设计

##  康威定律（1967年)
* 定义
```
 设计系统的结构，其产生的设计结果等同于团队（项目组）内部的结构以及团队（项目组）之间的沟通结构  
 用通俗的说法就是： 系统设计的架构类似于团队的角色（可兼职，重点是开发的角色定义）结构
```
* 延伸
```
第一定律:团队之间的沟通方式会通过系统设计表达出来
沟通成本 = n(n-1)/2，沟通成本随着团队的人员增加呈指数级增长
```

```
第二定律:时间再多、能力再强，一件事情也不可能做的完美，但总有时间做完一件事情
对于一个软件产品，做到没有bug、异常，可以响应任何用户的任何输入，并且保持高稳定的性能，只是理想的产品。
另一种则是保持弹性的性能，可以满足用户的正常输入的响应，即使发生错误，只要及时恢复【自动或者人工】，也能正常工作，这是现实。
```

```
第三定律:线型系统和线型组织架构间有潜在的异质同态特性，做独立自治的系统减少沟通成本，需要什么样的系统就配置什么样的团队
```

```
第四定律:大的系统组织总是比小系统更倾向于分解
```
## 微服务概念
* 定义
```
微服务架构的设计是将一个系统应用程序根据业务拆分开发为一个小型的、无中心的、只做一件（一类）事情的、独立组件的小型服务的架构设计方法。 
每个小型服务独立中运行、自治（至少是同一台机器的不同进程、可以一同一个机架的不同机器、同一个机房的不同机架上的机器、甚至是不同机房的机器）。
各个小型服务之间轻量级机制（通常是HTTP资源API、RPC，gRPC）进行通信。 
这些服务围绕业务功能构建，可通过全自动部署机制独立部署，可以根据业务流量进行不同的集群部署。 
这些服务保持最低限度的集中式管理。
可以用不同的编程语言编写，并使用不同的数据存储技术。
实现敏捷开发和部署。
```
* 特性
```
100%的组件化（组件是一个可独立替换和升级的业务软件单元。可以快速的、简单的开发、维护与升级）
分布式服务组成的系统
按照业务而不是技术来划分组织
做有生命的产品而不是项目
强服务个体和弱通信
自动化运维（DevOps）
容错、限流
快速演化
```
* 好处
```
1、技术异构性
    根据不同服务的业务中：用户流量、业务复杂度、数据读写频率和存储量采取不同的技术来实现
2、超级弹性
    软件工程中的弹性主要是指某个功能的故障影响到整体系统的使用情况。显然，微服务的 弹性是目前弹性最好的。
3、任意扩张性【永远变化】
4、简单部署性
5、组织相关性
6、简单的可组合性
7、增强的可替代性

```
* 坏处
```
1、网络请求负担
2、去中心化之后各个自治团队能力不均衡
3、学习成本
    微服务的实施会采用新的架构，或者是直接新架构的替换，
    或者是架构的渐进演化，但是都需要参与人员熟悉新架构的使用，
    以及全新的开发模式的适应
```

## 微服务的实施
* 分区
```
    1 确定服务边界以及服务上下文【提供的API和调用的API】
    2 服务直接的交互规范与协议【rpc？http？grpc?】
    3 服务直接通信要少，基于版本的通信，低版本API要及时关闭【不废除】
    4 服务直接必须隐藏内部实现细节，所有API要只做该服务内原子型的事情，并且在传参和返回结果上保持版本号一致
        【为了高效的性能，对于处理耗时的服务应该提供同步和异步的两个API；对于频繁调用的服务，应该增加批处理的API，并且在返回结果中明确、友好的告知被调用服务
          同时，针对处理耗时或者频繁的服务，被调用方必须要调用开始做好校验，必要的时候禁止服务调用】
    5 异构技术的服务之间的通信要保证技术永远无关性：
        5.1 比如服务A用Java编写的用户照片美化服务,服务B用Python采用开源的TensorFlow基于CPU编写的用户照片处理服务，
            A采用http方式调用B服务，将用户照片传送到B服务，B服务验证、修复照片，然后将处理后照片的结果再返回给A服务。
            后期由于TensorFlow功能的局限型，采用C语言基于GPU从零开始研发自己的照片处理软件，使其性能更高、更稳定。
            从而代替python开发的B服务。
            此时，A服务继续采用http调用可以准确的返回所需的结果。
        5.2 对于同一种技术实现的服务，服务直接的通信要采用同一种标准。要么用REST的http，要么用RPC，最好不要同时使用两种方式.
    6 分区过程：按照业务功能分服务 - 确定上下文 - 整理共享库【数据、工具】 - 反馈  整个工程是渐进式的逐步进行 
    7 服务内部要严格遵循DDY(don't repeat youself),而在服务直接要尽量避免DDY
```
* 原则（简单、量少）：
```
    1 整体原则
    2 分区原则：耦合低、松 ；内聚高、紧；
    3 服务原则
    4 技术原则
    5 上下文原则：对上限流、对下容错；不应该复杂，当上下文过于复杂时要及时的继续分区
    
```
* 原则债务
``` 
一些紧急的需求或者异常修复，为了快速响应需求，尽早上线。对于一些原则可能没有精力顾及，这是允许的。
```
* 原则预支
``` 
一些新需求的开发中，可能某些设计遵循一个新的原则会带来更好的结果，但是该原则还暂未公布，可以先使用该原则
然后上线之后在将该原则按照标准流程公布。
```
* 实践：
```
    1 需求驱动发布
    2 测试驱动开发
    3 回归驱动发布
    4 发布驱动原则
```
* 基础设施建设：
```
    1 版本控制
    2 自动化构建
    3 流水线发布
    4 持续交付与集成
    5 日志系统
    6 中台组件
    7 监控、报警系统
    8 devops
```

## 部署
* 持续集成（CI） ：不同分支编码到构建再到测试的反复持续过程，就叫作持续集成
* 持续交付(CD) ：在持续集成之后，获取外部对软件的反馈再通过持续集成进行优化的过程叫做持续交付，是持续集成的延伸
* 持续部署 ：将持续交付的结果在测试、预发、生产环境部署的过程叫做持续部署。
* devops : 研发【dev】与运维【ops】的综合体
```
dev:为软件新增功能和修复已有功能，使软件适应客户的市场需求和用户的最终体验，需要软件频繁的变更。
ops:保证软件的高稳定性，软件变更越频繁，越不稳定
devops的思想：通过技术升级和软件工程文化的进化，使dev与ops的矛盾最小化
devops是持续集成、交付和部署与容器化、容器管理、自动化运维的技术的整合，
    目的是使软件频繁变更的过程成本与代价最小，同时还能够保持较高的稳定性。
```

## 测试
* 单元测试：junit【测试驱动开发】
* 服务测试:swagger
* 全链路测试:人工
* 全面测试:人工
## 监控
* 资源监控：cpu、io、内存、磁盘资源使用情况
* API监控：API热度、失败比例
* 服务监控：各个服务健康情况、异常报警、集群负载均衡度、调用响应时长
* 用户行为监控：全链路追踪
* 数据库监控、消息队列监控等持久化存储层
* 第三方依赖监控：使用了第三方服务，比如百度地图，对其接口的健康监控
 
## 安全



# 微服务实施【Spring Cloud】

## 前端

## 网关

## 注册中心

## 服务调用

## 全链路追踪

## 持续交付/集成

## devops

## elk

## 测试驱动开发

## 插件式的中间件


# 分布式算法

# 持续交付与devops

# 工业级别的Spring cloud构建工具：JHipster